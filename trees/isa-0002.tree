\date{2025-11-25}
\author{liamoc}
\title{Building up HOL}
\taxon{Lecture}
\import{shiki-macros}
\put\shiki/language{Isabelle Theory}

\transclude{isa-0003}

\shiki{theory ND
  imports Pure
begin

typedecl bool
judgment Trueprop :: "bool ⇒ prop"  (‹(_)› 5)
}

\transclude{isa-0005}
\transclude{isa-0004}
\transclude{isa-0006}
\transclude{isa-0007}
\transclude{isa-0008}


\shiki{
lemma conjE : ‹⟦ A ∧ B ; ⟦ A ; B ⟧ ⟹ C ⟧ ⟹ C›
  apply (frule conjunct1)
  apply (drule conjunct2)
  apply (assumption)
  done

lemma impE: ‹⟦ P ⟶ Q; P ; Q ⟹ R ⟧ ⟹ R›
  apply (drule mp)
   apply assumption
   apply assumption
  done}

\transclude{isa-0009}
\transclude{isa-000A}
\transclude{isa-000B}
\shiki{
axiomatization where
  classical: ‹⟦ ¬ P ⟹ P ⟧ ⟹ P›

lemma ccontr: "⟦ ¬ P ⟹ False ⟧ ⟹ P"
  apply (rule classical)
  apply (rule FalseE)
  by (assumption)

lemma ‹¬ ¬ X ⟶ X›
  apply (rule impI)
  apply (rule ccontr)
  apply (erule notE)
  apply assumption
  done

lemma dm1: ‹¬ (A ∧ B) ⟶ ¬ A ∨ ¬ B›
  apply (rule impI)
  apply (rule ccontr)
  apply (erule notE)
  apply (rule conjI)
   apply (rule ccontr)
   apply (erule notE)
   apply (rule disjI1)
   apply assumption
  apply (rule ccontr)
  apply (erule notE)
  apply (rule disjI2)
  apply assumption
  done

lemma ‹¬ (A ⟶ B) ⟶ A›
  apply (rule impI)
  apply (rule ccontr)
  apply (erule notE)
  apply (rule impI)
  apply (erule notE)
  apply assumption
  done

lemma ‹¬ A ∧ ¬ B ⟶ ¬ (A ∨ B)›
  apply (rule impI)
  apply (erule conjE)
  apply (rule notI)
  apply (erule disjE)
   apply (erule notE, assumption)
  apply (erule notE, assumption)
  done

lemma ‹¬ (A ∨ B) ⟶ ¬ A ∧ ¬ B›
  apply (rule impI)
  apply (rule conjI)
   apply (rule notI)
   apply (erule notE)
   apply (rule disjI1)
   apply (assumption)
  apply (rule notI)
   apply (erule notE)
   apply (rule disjI2)
   apply (assumption)
  done

lemma ‹(A ⟶ B) ⟶ ((B ⟶ C) ⟶ A) ⟶ B›
  apply (intro impI)
  apply (rule ccontr)
  apply (erule impE)
  apply (drule mp)
   apply (rule impI)
   apply (erule notE)
  apply assumption
   apply assumption
  apply (erule notE)
  apply assumption
  done

axiomatization
  All :: ‹('a ⇒ bool) ⇒ bool›  (binder "∀" 10) and
  Ex :: ‹('a ⇒ bool) ⇒ bool›  (binder "∃" 10)
where
  allI : ‹⟦ ⋀x. P x ⟧ ⟹ ∀ x. P x› and
  spec : ‹∀ a. P a ⟹ P x› and 
  exI : ‹⟦ P x ⟧ ⟹ ∃a. P a› and 
  exE : ‹⟦ ∃ x. P x ; ⋀a. P a ⟹ R ⟧ ⟹ R›

lemma allE : ‹⟦ ∀a. P a; P x ⟹ R ⟧ ⟹ R›
  apply (drule_tac x = x in spec)
  apply assumption
  done

lemma ‹∀x. ¬ P x ⟹ ¬ (∃x. P x)›
  apply (rule notI)
  apply (erule exE)
  apply (erule_tac x = a in allE)
  apply (erule notE)
  apply assumption
  done


lemma foobl: ‹¬ (∃x. P x) ⟹ ∀x. ¬ P x›
  apply (intro allI notI)
  apply (erule notE)
  apply (rule exI)
  apply assumption
  done

lemma ‹∃ x y. P x y ⟹ ∃ y x. P x y›
  apply (elim exE)
  apply (intro exI)
  apply assumption
  done

lemma ‹∃ x. P x ⟶ Q ⟹ (∀ x. P x) ⟶ Q›
  apply (intro impI)
  apply (elim exE)
  apply (drule_tac x = a in spec)
  apply (drule mp, assumption)
  apply assumption
  done


lemma ‹(∀ x. P x) ⟶ Q ⟹ ∃ x. P x ⟶ Q›
  apply (rule ccontr)
  apply (elim impE)
   apply (intro allI)
   apply (rule ccontr)
   apply (erule notE)
   apply (rule_tac x = x in exI)
   apply (rule impI)
   apply (erule notE)
   apply assumption
  apply (erule notE)
  apply (intro exI)
  apply (rule impI)
  apply assumption
  done

lemma ‹(∀ x. P x) ⟶ (∃ x. Q x) ⟹ ∃ x. P x ⟶ Q x›
  apply (rule ccontr)
  apply (elim impE)
   apply (intro allI)
   apply (rule ccontr)
   apply (erule notE)
   apply (rule_tac x = x in exI)
   apply (rule impI)
   apply (erule notE)
   apply assumption
  apply (erule notE)
  apply (erule exE)
  apply (intro exI)
  apply (rule impI)
  apply assumption
  done


lemma ‹ ∃ x. P x ⟶ Q x ⟹ (∀ x. P x) ⟶ (∃ x. Q x)›
  apply (rule impI)
  apply (elim exE)
  apply (drule_tac x = a in spec)
  apply (drule mp, assumption)
  apply (rule exI)
  apply assumption
  done

lemma ‹∀ x. ¬ R x ⟶ R (M x) ⟹ ∀ x. R x ∨ R (M x)›
  apply (intro allI)
  apply (erule_tac x = x in allE)
  apply (rule ccontr)
  apply (erule impE)
   apply (rule notI)
   apply (erule notE)
   apply (rule disjI1)
   apply assumption
  apply (erule notE)
  apply (rule disjI2)
  apply assumption
  done

lemma helper: "¬ A ⟶ B ⟹ A ∨ B" 
  apply (rule ccontr)
  apply (erule impE)
   apply (rule notI)
   apply (erule notE)
   apply (rule disjI1)
   apply assumption
  apply (erule notE)
  apply (rule disjI2)
  apply assumption
  done

lemma ‹⟦∀ x. ¬ R x ⟶ R (M x); ∃ x. R x ⟧ ⟹ ∃ x. R x ∧ R (M (M x))›
  apply (erule exE)
  apply (frule_tac x = a in allE, assumption)
  apply (drule_tac x = a in spec)
  apply (frule_tac x = "M a" in spec)
  apply (drule_tac x = "M (M a)" in spec)
  apply (drule helper)+
  apply (elim disjE) 
         apply (rule_tac x = a in exI; intro conjI; assumption)
        apply (rule_tac x = "M a" in exI; intro conjI; assumption)
       apply (rule_tac x = a in exI; intro conjI; assumption)
      apply (rule_tac x = a in exI; intro conjI; assumption)
     apply (rule_tac x = a in exI; intro conjI; assumption)
    apply (rule_tac x = "M a" in exI; intro conjI; assumption)
   apply (rule_tac x = a in exI; intro conjI; assumption)
  apply (rule_tac x = a in exI; intro conjI; assumption)
  done
}