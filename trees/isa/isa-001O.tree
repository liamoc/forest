\date{2025-12-03T02:48:14Z}
\import{shiki-macros}
\import{dt-macros}
\put\shiki/language{Isabelle Theory}
\title{Defining functions in Isabelle}
\p{The \code{fun} command can be used to define functions in Isabelle. Unlike [\code{definition}s](isa-001G), functions can be defined by \em{multiple} pattern-matching equations, they may be recursive, and their equations are automatically added to [the simpset](isa-001H).}
\subtree{\taxon{Example}\title{Fibonacci as a \code{fun}}\author{liamoc}
\shiki{fun fib :: "nat ⇒ nat" where
  "fib 0 = 0"
| "fib (Suc 0) = Suc 0"
| "fib (Suc (Suc n)) = fib n + fib (Suc n)"
print_theorems}
}
\p{The \code{print_theorems} command allows us to see all of the lemmas generated by this command.
}
\problemblock{
  \p{Isabelle functions must provably terminate. The problem with non-terminating functions can be illustrated by a definition like:}
  \shiki{fun bad :: "nat ⇒ bool" where "bad x = ¬ (bad x)"}
  \p{If such a non-terminating definition were allowed, this would render our logic inconsistent (as \code{bad x} is equal to its own negation). Therefore, Isabelle requires that all functions be accompanied by a proof of termination.}
  \p{The \code{fun} command attempts to prove termination automatically. If it does not succeed, it will give an error message and fail to define the function. Manual proofs of termination can be supplied if the \code{function} command is used instead, but the \code{function} command is beyond the scope of this course. }
}
\p{In cases where the recursion and pattern matching follows exactly the structure of the datatype in one argument, \code{primrec} can be used instead of \code{fun}, which is a bit more efficient:}
\transclude{isa-001R}